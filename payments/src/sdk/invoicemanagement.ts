/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { encodeJSON as encodeJSON$, encodeSimple as encodeSimple$ } from "../lib/encodings.js";
import * as m$ from "../lib/matchers.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { SDKError } from "./models/errors/sdkerror.js";
import { SDKValidationError } from "./models/errors/sdkvalidationerror.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";
import { unwrap as unwrap$ } from "./types/fp.js";

export class InvoiceManagement extends ClientSDK {
    /**
     * Initiate New Invoice for a Member
     *
     * @remarks
     * Facilitates the creation of a new invoice for a member using the provided invoice details. Useful for adding new billing records.
     */
    async create(
        request?: shared.InvoiceCreateRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.InvoiceCreateRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/invoice")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateInvoiceResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.CreateInvoiceResponse$inboundSchema, { key: "Invoice" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Create a new client-generated invoice template
     *
     * @remarks
     * Allows clients to create a new invoice template based on the provided details.
     */
    async createClient(
        request?: shared.ClientInvoiceTemplateCreateRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateClientInvoiceTemplateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                shared.ClientInvoiceTemplateCreateRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/client/invoice-template")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createClientInvoiceTemplate",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateClientInvoiceTemplateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateClientInvoiceTemplateResponse$inboundSchema, {
                key: "ClientInvoiceTemplate",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Generate a New Invoice on Behalf of the Client
     *
     * @remarks
     * Enables the creation of a new invoice on behalf of a client using the provided details, facilitating new billing records.
     */
    async createGenerated(
        request?: shared.ClientInvoiceCreateRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateGeneratedInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ClientInvoiceCreateRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/client/invoice")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createGeneratedInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateGeneratedInvoiceResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateGeneratedInvoiceResponse$inboundSchema, {
                key: "ClientInvoice",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Create a new invoice template
     *
     * @remarks
     * Creates a new invoice template based on the provided details.
     */
    async createTemplate(
        request?: shared.InvoiceTemplateCreateRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateInvoiceTemplateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.InvoiceTemplateCreateRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/invoice-template")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createInvoiceTemplate",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateInvoiceTemplateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateInvoiceTemplateResponse$inboundSchema, {
                key: "InvoiceTemplate",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Remove Invoice Record by ID
     *
     * @remarks
     * Enables the deletion of a specific member's invoice using its unique ID, helping in maintaining accurate billing records.
     */
    async delete(
        request: operations.DeleteInvoiceRequest,
        options?: RequestOptions
    ): Promise<operations.DeleteInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.DeleteInvoiceRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/invoice/{id}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "deleteInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.DeleteInvoiceResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.DeleteInvoiceResponse$inboundSchema, { key: "Invoice" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Remove a specific invoice template
     *
     * @remarks
     * Deletes the invoice template associated with the provided unique identifier.
     */
    async deleteTemplate(
        request: operations.DeleteInvoiceTemplateRequest,
        options?: RequestOptions
    ): Promise<operations.DeleteInvoiceTemplateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.DeleteInvoiceTemplateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/invoice-template/{id}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "deleteInvoiceTemplate",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.DeleteInvoiceTemplateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DeleteInvoiceTemplateResponse$inboundSchema, {
                key: "InvoiceTemplate",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Execute Payment for a Client-Generated Invoice
     *
     * @remarks
     * Process a payment for a specific client-generated invoice using the provided details, ensuring the invoice is marked as settled.
     */
    async execute(
        request: operations.ExecuteClientInvoicePaymentRequest,
        options?: RequestOptions
    ): Promise<operations.ExecuteClientInvoicePaymentResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.ExecuteClientInvoicePaymentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.PayRequest, { explode: true });

        const pathParams$ = {
            invoice_id: encodeSimple$("invoice_id", payload$.invoice_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/client/invoice/{invoice_id}/pay")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "executeClientInvoicePayment",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ExecuteClientInvoicePaymentResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ExecuteClientInvoicePaymentResponse$inboundSchema, {
                key: "ClientInvoice",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Generate a PDF for a specific invoice
     *
     * @remarks
     * This endpoint allows for the dynamic generation of a PDF document for a given invoice, identified by its unique ID.
     */
    async generate(
        request: operations.GenerateSpecificInvoiceRequest,
        options?: RequestOptions
    ): Promise<operations.GenerateSpecificInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GenerateSpecificInvoiceRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            invoice_id: encodeSimple$("invoice_id", payload$.invoice_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/invoice/{invoice_id}/generate")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "generateSpecificInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GenerateSpecificInvoiceResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GenerateSpecificInvoiceResponse$inboundSchema, {
                key: "InvoicePdfGenerationResponse",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Generate Test Invoice for a Client
     *
     * @remarks
     * Use this endpoint to create a test invoice for testing and validation purposes. This invoice will mimic a client's real invoice.
     */
    async generateTest(
        request?: shared.TestInvoiceCreate | undefined,
        options?: RequestOptions
    ): Promise<operations.GenerateTestInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.TestInvoiceCreate$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/invoice/test/create")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "generateTestInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GenerateTestInvoiceResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GenerateTestInvoiceResponse$inboundSchema, {
                key: "ClientInvoice",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Fetch Invoice by ID
     *
     * @remarks
     * Retrieve the specifics of an individual invoice associated with a member using its unique ID. Ideal for diving into invoice details.
     */
    async get(
        request: operations.GetInvoiceRequest,
        options?: RequestOptions
    ): Promise<operations.GetInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetInvoiceRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/invoice/{id}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetInvoiceResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.GetInvoiceResponse$inboundSchema, { key: "Invoice" }))(response, {
            extraFields: responseFields$,
        });

        return unwrap$(result$);
    }

    /**
     * Fetch a specific client-generated invoice template by ID
     *
     * @remarks
     * Provides details of the client-generated invoice template associated with the provided unique identifier.
     */
    async getClient(
        request: operations.GetClientInvoiceTemplateRequest,
        options?: RequestOptions
    ): Promise<operations.GetClientInvoiceTemplateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetClientInvoiceTemplateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/client/invoice-template/{id}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getClientInvoiceTemplate",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetClientInvoiceTemplateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetClientInvoiceTemplateResponse$inboundSchema, {
                key: "ClientInvoiceTemplate",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve Fees Associated with a Client's Invoice
     *
     * @remarks
     * Obtain a detailed breakdown of all the fees associated with a specific client's invoice, identified by its unique ID.
     */
    async getFees(
        request: operations.GetInvoiceFeesRequest,
        options?: RequestOptions
    ): Promise<operations.GetInvoiceFeesResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetInvoiceFeesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            invoice_id: encodeSimple$("invoice_id", payload$.invoice_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/client/invoice/{invoice_id}/fees")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getInvoiceFees",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetInvoiceFeesResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetInvoiceFeesResponse$inboundSchema, {
                key: "InvoiceFeeCalculation",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Fetch Specific Client-Generated Invoice by ID
     *
     * @remarks
     * Retrieve detailed information of an individual invoice created by a client using its unique ID for in-depth billing analysis.
     */
    async getGenerated(
        request: operations.GetGeneratedInvoiceRequest,
        options?: RequestOptions
    ): Promise<operations.GetGeneratedInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetGeneratedInvoiceRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/client/invoice/{id}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getGeneratedInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetGeneratedInvoiceResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetGeneratedInvoiceResponse$inboundSchema, {
                key: "ClientInvoice",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve All Member Invoices
     *
     * @remarks
     * Fetch a complete list of invoices associated with members, providing a comprehensive overview of all member-related billing details.
     */
    async getMember(options?: RequestOptions): Promise<operations.GetMemberInvoicesResponse> {
        const path$ = pathToFunc("/payments/invoice")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getMemberInvoices",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetMemberInvoicesResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.GetMemberInvoicesResponse$inboundSchema, { key: "classes" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Retrieve a specific invoice template by ID
     *
     * @remarks
     * Fetches details of the invoice template corresponding to the provided unique identifier.
     */
    async getTemplate(
        request: operations.GetInvoiceTemplateRequest,
        options?: RequestOptions
    ): Promise<operations.GetInvoiceTemplateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetInvoiceTemplateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/invoice-template/{id}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getInvoiceTemplate",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetInvoiceTemplateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetInvoiceTemplateResponse$inboundSchema, {
                key: "InvoiceTemplate",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve All Invoices Generated by a Client
     *
     * @remarks
     * Fetch a comprehensive list of invoices that have been generated by a client, offering an overview of all client-related billing records.
     */
    async list(options?: RequestOptions): Promise<operations.ListGeneratedInvoicesResponse> {
        const path$ = pathToFunc("/payments/client/invoice")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listGeneratedInvoices",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListGeneratedInvoicesResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.ListGeneratedInvoicesResponse$inboundSchema, { key: "classes" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Retrieve all client-generated invoice templates
     *
     * @remarks
     * Fetches a comprehensive list of all invoice templates created by clients in the system.
     */
    async listClient(
        options?: RequestOptions
    ): Promise<operations.ListClientInvoiceTemplatesResponse> {
        const path$ = pathToFunc("/payments/client/invoice-template")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listClientInvoiceTemplates",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListClientInvoiceTemplatesResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ListClientInvoiceTemplatesResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve all available invoice templates
     *
     * @remarks
     * Fetches a comprehensive list of all invoice templates in the system.
     */
    async listTemplates(
        options?: RequestOptions
    ): Promise<operations.ListInvoiceTemplatesResponse> {
        const path$ = pathToFunc("/payments/invoice-template")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listInvoiceTemplates",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListInvoiceTemplatesResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.ListInvoiceTemplatesResponse$inboundSchema, { key: "classes" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Refund a deposited invoice
     *
     * @remarks
     * Use this endpoint to refund a specific amount of a deposited invoice.
     */
    async refund(
        request: operations.RefundDepositedInvoiceRequest,
        options?: RequestOptions
    ): Promise<operations.RefundDepositedInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.RefundDepositedInvoiceRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.InvoiceRefundRequest, { explode: true });

        const pathParams$ = {
            invoice_id: encodeSimple$("invoice_id", payload$.invoice_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/invoice/{invoice_id}/refund")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "refundDepositedInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.RefundDepositedInvoiceResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RefundDepositedInvoiceResponse$inboundSchema, {
                key: "Invoice",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Send an invoice by email
     *
     * @remarks
     * Use this endpoint to send an invoice by email using its unique ID for identification.
     */
    async send(
        request: operations.SendInvoiceEmailRequest,
        options?: RequestOptions
    ): Promise<operations.SendInvoiceEmailResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.SendInvoiceEmailRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            invoice_id: encodeSimple$("invoice_id", payload$.invoice_id, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/invoice/{invoice_id}/send")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "sendInvoiceEmail",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.SendInvoiceEmailResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.SendInvoiceEmailResponse$inboundSchema, { key: "Invoice" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Modify Existing Invoice Details
     *
     * @remarks
     * Allows updates to the details of an existing member invoice using its unique ID. Useful for making corrections or updates to billing records.
     */
    async update(
        request: operations.UpdateInvoiceRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateInvoiceRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.InvoiceUpdateRequest, { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/invoice/{id}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateInvoiceResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.UpdateInvoiceResponse$inboundSchema, { key: "Invoice" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Modify a client-generated invoice template
     *
     * @remarks
     * Updates the specified client-generated invoice template with the provided modifications.
     */
    async updateClient(
        request: operations.UpdateClientInvoiceTemplateRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateClientInvoiceTemplateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateClientInvoiceTemplateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.ClientInvoiceTemplateUpdateRequest, {
            explode: true,
        });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/client/invoice-template/{id}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateClientInvoiceTemplate",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateClientInvoiceTemplateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateClientInvoiceTemplateResponse$inboundSchema, {
                key: "ClientInvoiceTemplate",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify an Existing Client-Generated Invoice
     *
     * @remarks
     * Allows for modifications to a client-generated invoice using its unique ID, ensuring billing details remain current and accurate.
     */
    async updateGenerated(
        request: operations.UpdateGeneratedInvoiceRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateGeneratedInvoiceResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateGeneratedInvoiceRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.ClientInvoiceUpdateRequest, { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/client/invoice/{id}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateGeneratedInvoice",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateGeneratedInvoiceResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateGeneratedInvoiceResponse$inboundSchema, {
                key: "ClientInvoice",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify details of an existing invoice template
     *
     * @remarks
     * Updates details of the specified invoice template based on the provided information.
     */
    async updateTemplate(
        request: operations.UpdateInvoiceTemplateRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateInvoiceTemplateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateInvoiceTemplateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.InvoiceTemplateUpdateRequest, { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/invoice-template/{id}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateInvoiceTemplate",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateInvoiceTemplateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateInvoiceTemplateResponse$inboundSchema, {
                key: "InvoiceTemplate",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }
}
