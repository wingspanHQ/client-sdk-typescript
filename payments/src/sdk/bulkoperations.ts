/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { encodeJSON as encodeJSON$, encodeSimple as encodeSimple$ } from "../lib/encodings.js";
import * as m$ from "../lib/matchers.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { SDKError } from "./models/errors/sdkerror.js";
import { SDKValidationError } from "./models/errors/sdkvalidationerror.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";
import { unwrap as unwrap$ } from "./types/fp.js";

export class BulkOperations extends ClientSDK {
    /**
     * Initiate a New Bulk Invoice Batch
     *
     * @remarks
     * Creates a new batch for importing multiple invoices at once, streamlining the bulk invoicing operations.
     */
    async create(
        request?: shared.BulkInvoiceBatchCreate | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateInvoiceBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.BulkInvoiceBatchCreate$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/bulk/invoice/batch")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createInvoiceBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateInvoiceBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateInvoiceBatchResponse$inboundSchema, {
                key: "BulkInvoiceBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Add a new item to a specific bulk payable batch
     *
     * @remarks
     * Allows for the creation and addition of a new individual payable item into an existing bulk payable batch. This enhances batch management and payable tracking.
     */
    async createBatchItem(
        request: operations.CreatePayableBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.CreatePayableBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.CreatePayableBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkPayableItemCreate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/payable/batch/{batchId}/item")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createPayableBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreatePayableBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreatePayableBatchItemResponse$inboundSchema, {
                key: "BulkPayableItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Create a new bulk client batch
     *
     * @remarks
     * Initiates the creation of a fresh bulk client batch, streamlining the process of adding multiple clients in one go.
     */
    async createClient(
        request?: shared.BulkBatchCreate | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateClientBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.BulkBatchCreate$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/bulk/client/batch")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createClientBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateClientBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateClientBatchResponse$inboundSchema, {
                key: "BulkClientBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Add a New Item to a Client Batch
     *
     * @remarks
     * Inserts a new item into the specified bulk client batch, allowing for further expansion of client data within the batch.
     */
    async createClientItem(
        request: operations.CreateClientBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.CreateClientBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.CreateClientBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkClientItemCreate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/client/batch/{batchId}/item")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createClientBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateClientBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateClientBatchItemResponse$inboundSchema, {
                key: "BulkClientItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Initiate a new bulk collaborator batch.
     *
     * @remarks
     * Enables the creation of a new bulk collaborator batch, facilitating the bulk management and addition of collaborators for various projects or tasks.
     */
    async createCollaborator(
        request?: shared.BulkBatchCreate | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateCollaboratorBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.BulkBatchCreate$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/bulk/collaborator/batch")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createCollaboratorBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateCollaboratorBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateCollaboratorBatchResponse$inboundSchema, {
                key: "BulkCollaboratorBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Initiate a New Bulk Payable Batch
     *
     * @remarks
     * Creates a new batch for importing multiple payables at once, streamlining the bulk payment operations.
     */
    async createPayable(
        request?: shared.BulkPayableBatchCreate | undefined,
        options?: RequestOptions
    ): Promise<operations.CreatePayableBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.BulkPayableBatchCreate$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/bulk/payable/batch")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createPayableBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreatePayableBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreatePayableBatchResponse$inboundSchema, {
                key: "BulkPayableBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Append a new item to a specific collaborator batch
     *
     * @remarks
     * Allows for the addition of a new item to an existing batch of collaborators by providing the batchs unique identifier and item details.
     */
    async createSpecificCollaboratorItem(
        request: operations.CreateSpecificCollaboratorBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.CreateSpecificCollaboratorBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.CreateSpecificCollaboratorBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkCollaboratorItemCreate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/collaborator/batch/{batchId}/item")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createSpecificCollaboratorBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateSpecificCollaboratorBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateSpecificCollaboratorBatchItemResponse$inboundSchema, {
                key: "BulkCollaboratorItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Add a new item to a specific bulk invoice batch
     *
     * @remarks
     * Allows users to append a new item to a given batch of bulk invoices by supplying its unique batch identifier and the details of the new item.
     */
    async createSpecificInvoice(
        request: operations.CreateSpecificInvoiceBatchRequest,
        options?: RequestOptions
    ): Promise<operations.CreateSpecificInvoiceBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.CreateSpecificInvoiceBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkInvoiceItemCreate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/invoice/batch/{batchId}/item")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createSpecificInvoiceBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreateSpecificInvoiceBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreateSpecificInvoiceBatchResponse$inboundSchema, {
                key: "BulkInvoiceItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Remove a Specific Collaborator Batch
     *
     * @remarks
     * Deletes a specific bulk collaborator batch using its unique identifier. Once deleted, the batch cannot be recovered.
     */
    async deleteCollaborator(
        request: operations.DeleteCollaboratorBatchRequest,
        options?: RequestOptions
    ): Promise<operations.DeleteCollaboratorBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.DeleteCollaboratorBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/collaborator/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "deleteCollaboratorBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.DeleteCollaboratorBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DeleteCollaboratorBatchResponse$inboundSchema, {
                key: "BulkCollaboratorBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Remove a Specific Bulk Payable Batch
     *
     * @remarks
     * Deletes a specific batch for bulk payables, using the provided batch ID, preventing any further operations on it.
     */
    async deletePayable(
        request: operations.DeletePayableBatchRequest,
        options?: RequestOptions
    ): Promise<operations.DeletePayableBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.DeletePayableBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/payable/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "deletePayableBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.DeletePayableBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DeletePayableBatchResponse$inboundSchema, {
                key: "BulkPayableBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve details of a specific bulk invoice batch
     *
     * @remarks
     * Allows for the retrieval of a specified batch of bulk invoices by providing its unique batch identifier.
     */
    async get(
        request: operations.GetInvoiceBatchRequest,
        options?: RequestOptions
    ): Promise<operations.GetInvoiceBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetInvoiceBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/invoice/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getInvoiceBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetInvoiceBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetInvoiceBatchResponse$inboundSchema, {
                key: "BulkInvoiceBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Fetch the import summary for a specific bulk payable batch
     *
     * @remarks
     * Provides an overview and summary of the import process for a given bulk payable batch, allowing for tracking of imported items, errors, and other relevant batch statistics.
     */
    async getBatchItem(
        request: operations.GetPayableBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.GetPayableBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetPayableBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/payable/batch/{batchId}/import-summary")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getPayableBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetPayableBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetPayableBatchItemResponse$inboundSchema, {
                key: "BulkPayableImportSummary",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Fetch Details of a Specific Item from a Client Batch
     *
     * @remarks
     * Retrieves the detailed information of a specific item within the bulk client batch using both batch and item unique identifiers.
     */
    async getClient(
        request: operations.GetClientBatchRequest,
        options?: RequestOptions
    ): Promise<operations.GetClientBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetClientBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/client/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getClientBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetClientBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetClientBatchResponse$inboundSchema, {
                key: "BulkClientBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Fetch Details of a Specific Item from a Client Batch
     *
     * @remarks
     * Retrieves the detailed information of a specific item within the bulk client batch using both batch and item unique identifiers.
     */
    async getClientItem(
        request: operations.GetClientBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.GetClientBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetClientBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
            batchItemId: encodeSimple$("batchItemId", payload$.batchItemId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/client/batch/{batchId}/item/{batchItemId}")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getClientBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetClientBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetClientBatchItemResponse$inboundSchema, {
                key: "BulkClientItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve Details of a Specific Collaborator Batch
     *
     * @remarks
     * Fetches detailed information of a specific bulk collaborator batch, using the provided batch ID.
     */
    async getCollaborator(
        request: operations.GetCollaboratorBatchRequest,
        options?: RequestOptions
    ): Promise<operations.GetCollaboratorBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetCollaboratorBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/collaborator/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getCollaboratorBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetCollaboratorBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetCollaboratorBatchResponse$inboundSchema, {
                key: "BulkCollaboratorBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve Details of a Specific Bulk Payable Batch
     *
     * @remarks
     * Fetches detailed information of a specific batch created for bulk payables, using the provided batch ID.
     */
    async getPayable(
        request: operations.GetPayableBatchRequest,
        options?: RequestOptions
    ): Promise<operations.GetPayableBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetPayableBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/payable/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getPayableBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetPayableBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetPayableBatchResponse$inboundSchema, {
                key: "BulkPayableBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve a Specific Item from a Bulk Payable Batch
     *
     * @remarks
     * Fetches detailed information of a specific item within a bulk payable batch, using both the batch ID and the item ID.
     */
    async getSpecific(
        request: operations.GetSpecificPayableBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.GetSpecificPayableBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetSpecificPayableBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
            batchItemId: encodeSimple$("batchItemId", payload$.batchItemId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/payable/batch/{batchId}/item/{batchItemId}")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getSpecificPayableBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetSpecificPayableBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetSpecificPayableBatchItemResponse$inboundSchema, {
                key: "BulkPayableItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve details of a specific item from a collaborator batch
     *
     * @remarks
     * Enables fetching of detailed information about an individual item from a specified batch of collaborators using both the batch and item unique identifiers.
     */
    async getSpecificCollaboratorItem(
        request: operations.GetSpecificCollaboratorBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.GetSpecificCollaboratorBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.GetSpecificCollaboratorBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
            batchItemId: encodeSimple$("batchItemId", payload$.batchItemId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/collaborator/batch/{batchId}/item/{batchItemId}")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getSpecificCollaboratorBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetSpecificCollaboratorBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetSpecificCollaboratorBatchItemResponse$inboundSchema, {
                key: "BulkCollaboratorItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve a specific item from a bulk invoice batch
     *
     * @remarks
     * Fetches detailed information about a specific item located within a designated bulk invoice batch. Useful for obtaining particular item data without browsing the entire batch.
     */
    async getSpecificInvoice(
        request: operations.GetSpecificInvoiceBatchRequest,
        options?: RequestOptions
    ): Promise<operations.GetSpecificInvoiceBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetSpecificInvoiceBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
            batchItemId: encodeSimple$("batchItemId", payload$.batchItemId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/invoice/batch/{batchId}/item/{batchItemId}")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getSpecificInvoiceBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetSpecificInvoiceBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetSpecificInvoiceBatchResponse$inboundSchema, {
                key: "BulkInvoiceItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve All Bulk Invoice Batches
     *
     * @remarks
     * Fetches a list of all the batches created for bulk invoices, providing an overview of the bulk invoicing operations.
     */
    async list(options?: RequestOptions): Promise<operations.ListInvoiceBatchesResponse> {
        const path$ = pathToFunc("/payments/bulk/invoice/batch")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listInvoiceBatches",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListInvoiceBatchesResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.ListInvoiceBatchesResponse$inboundSchema, { key: "classes" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Retrieve all items from a specific bulk payable batch
     *
     * @remarks
     * Fetches and lists all individual payable items associated with a specified bulk payable batch. Useful for tracking and verifying batch details.
     */
    async listBatchItem(
        request: operations.ListPayableBatchItemsRequest,
        options?: RequestOptions
    ): Promise<operations.ListPayableBatchItemsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.ListPayableBatchItemsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/payable/batch/{batchId}/item")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listPayableBatchItems",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListPayableBatchItemsResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.ListPayableBatchItemsResponse$inboundSchema, { key: "classes" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Retrieve all bulk client batches
     *
     * @remarks
     * Provides an overview of all existing bulk client batches, allowing users to quickly ascertain and manage batches created for the purpose of client onboarding or import.
     */
    async listClient(options?: RequestOptions): Promise<operations.ListClientBatchesResponse> {
        const path$ = pathToFunc("/payments/bulk/client/batch")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listClientBatches",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListClientBatchesResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.ListClientBatchesResponse$inboundSchema, { key: "classes" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Retrieve All Items from a Client Batch
     *
     * @remarks
     * Fetches all items present in the specified bulk client batch, providing a comprehensive view of all client data in the batch.
     */
    async listClientItem(
        request: operations.ListClientBatchItemsRequest,
        options?: RequestOptions
    ): Promise<operations.ListClientBatchItemsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.ListClientBatchItemsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/client/batch/{batchId}/item")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listClientBatchItems",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListClientBatchItemsResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.ListClientBatchItemsResponse$inboundSchema, { key: "classes" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Fetch all bulk collaborator batches
     *
     * @remarks
     * Provides a list of all existing bulk collaborator batches, allowing users to view and manage batches that have been created for collaboration purposes.
     */
    async listCollaborator(
        options?: RequestOptions
    ): Promise<operations.ListCollaboratorBatchesResponse> {
        const path$ = pathToFunc("/payments/bulk/collaborator/batch")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listCollaboratorBatches",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListCollaboratorBatchesResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ListCollaboratorBatchesResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve All Bulk Payable Batches
     *
     * @remarks
     * Fetches a list of all the batches created for bulk payables, providing an overview of the bulk payment operations.
     */
    async listPayable(options?: RequestOptions): Promise<operations.ListPayableBatchesResponse> {
        const path$ = pathToFunc("/payments/bulk/payable/batch")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listPayableBatches",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListPayableBatchesResponse,
            SDKError | SDKValidationError
        >(m$.json(200, operations.ListPayableBatchesResponse$inboundSchema, { key: "classes" }))(
            response,
            { extraFields: responseFields$ }
        );

        return unwrap$(result$);
    }

    /**
     * Retrieve all items from a specific collaborator batch
     *
     * @remarks
     * Provides a comprehensive list of items present within a specified batch of collaborators, identifiable through its unique batch identifier.
     */
    async listSpecificCollaboratorItem(
        request: operations.ListSpecificCollaboratorBatchItemsRequest,
        options?: RequestOptions
    ): Promise<operations.ListSpecificCollaboratorBatchItemsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.ListSpecificCollaboratorBatchItemsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/collaborator/batch/{batchId}/item")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listSpecificCollaboratorBatchItems",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListSpecificCollaboratorBatchItemsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ListSpecificCollaboratorBatchItemsResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Fetch all items from a specific bulk invoice batch
     *
     * @remarks
     * Provides a list of all the items within a specified batch of bulk invoices, identified by its unique batch identifier.
     */
    async listSpecificInvoice(
        request: operations.ListSpecificInvoiceBatchesRequest,
        options?: RequestOptions
    ): Promise<operations.ListSpecificInvoiceBatchesResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.ListSpecificInvoiceBatchesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/invoice/batch/{batchId}/item")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listSpecificInvoiceBatches",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListSpecificInvoiceBatchesResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ListSpecificInvoiceBatchesResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify the details of a specific bulk invoice batch
     *
     * @remarks
     * Enables the user to update or modify the attributes of a given batch of bulk invoices by specifying its unique batch identifier.
     */
    async update(
        request: operations.UpdateInvoiceBatchRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateInvoiceBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateInvoiceBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkInvoiceBatchUpdate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/invoice/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateInvoiceBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateInvoiceBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateInvoiceBatchResponse$inboundSchema, {
                key: "BulkInvoiceBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify Details of a Specific Item in a Client Batch
     *
     * @remarks
     * Allows modification of the details of a specific item within the bulk client batch, using the provided item and batch identifiers.
     */
    async updateClient(
        request: operations.UpdateClientBatchRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateClientBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateClientBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkBatchUpdate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/client/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateClientBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateClientBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateClientBatchResponse$inboundSchema, {
                key: "BulkClientBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify Details of a Specific Item in a Client Batch
     *
     * @remarks
     * Allows modification of the details of a specific item within the bulk client batch, using the provided item and batch identifiers.
     */
    async updateClientItem(
        request: operations.UpdateClientBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateClientBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateClientBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkClientItemUpdate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
            batchItemId: encodeSimple$("batchItemId", payload$.batchItemId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/client/batch/{batchId}/item/{batchItemId}")(
            pathParams$
        );

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateClientBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateClientBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateClientBatchItemResponse$inboundSchema, {
                key: "BulkClientItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify Details of a Bulk Collaborator Batch
     *
     * @remarks
     * Allows for updating or altering the details and items within a specific bulk collaborator batch using the given batch ID.
     */
    async updateCollaborator(
        request: operations.UpdateCollaboratorBatchRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateCollaboratorBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateCollaboratorBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkBatchUpdate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/collaborator/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateCollaboratorBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateCollaboratorBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateCollaboratorBatchResponse$inboundSchema, {
                key: "BulkCollaboratorBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify a Specific Bulk Payable Batch
     *
     * @remarks
     * Updates the information or items of a specific bulk payable batch, given its unique batch ID.
     */
    async updatePayable(
        request: operations.UpdatePayableBatchRequest,
        options?: RequestOptions
    ): Promise<operations.UpdatePayableBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdatePayableBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkPayableBatchUpdate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/payable/batch/{batchId}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updatePayableBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdatePayableBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdatePayableBatchResponse$inboundSchema, {
                key: "BulkPayableBatch",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify a Specific Item in a Bulk Payable Batch
     *
     * @remarks
     * Updates the details or status of a specific item within a bulk payable batch, given both the batch ID and the item ID.
     */
    async updateSpecific(
        request: operations.UpdateSpecificPayableBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateSpecificPayableBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.UpdateSpecificPayableBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkPayableItemUpdate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
            batchItemId: encodeSimple$("batchItemId", payload$.batchItemId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/payable/batch/{batchId}/item/{batchItemId}")(
            pathParams$
        );

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateSpecificPayableBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateSpecificPayableBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateSpecificPayableBatchItemResponse$inboundSchema, {
                key: "BulkPayableItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify the details of a specific item within a collaborator batch
     *
     * @remarks
     * Provides the functionality to update or alter the attributes of an item present in a given collaborator batch using the unique identifiers for both the batch and the item.
     */
    async updateSpecificCollaboratorItem(
        request: operations.UpdateSpecificCollaboratorBatchItemRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateSpecificCollaboratorBatchItemResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.UpdateSpecificCollaboratorBatchItemRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkCollaboratorItemUpdate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
            batchItemId: encodeSimple$("batchItemId", payload$.batchItemId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/collaborator/batch/{batchId}/item/{batchItemId}")(
            pathParams$
        );

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateSpecificCollaboratorBatchItem",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateSpecificCollaboratorBatchItemResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateSpecificCollaboratorBatchItemResponse$inboundSchema, {
                key: "BulkCollaboratorItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify a specific item within a bulk invoice batch
     *
     * @remarks
     * Allows for updates or edits to be made to a specific items details within an existing bulk invoice batch. Enhances the flexibility and management of invoice data.
     */
    async updateSpecificInvoice(
        request: operations.UpdateSpecificInvoiceBatchRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateSpecificInvoiceBatchResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateSpecificInvoiceBatchRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.BulkInvoiceItemUpdate, { explode: true });

        const pathParams$ = {
            batchId: encodeSimple$("batchId", payload$.batchId, {
                explode: false,
                charEncoding: "percent",
            }),
            batchItemId: encodeSimple$("batchItemId", payload$.batchItemId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/payments/bulk/invoice/batch/{batchId}/item/{batchItemId}")(
            pathParams$
        );

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateSpecificInvoiceBatch",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateSpecificInvoiceBatchResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateSpecificInvoiceBatchResponse$inboundSchema, {
                key: "BulkInvoiceItem",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }
}
