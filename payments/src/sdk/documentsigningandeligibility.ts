/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { encodeJSON as encodeJSON$, encodeSimple as encodeSimple$ } from "../lib/encodings.js";
import * as m$ from "../lib/matchers.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { SDKError } from "./models/errors/sdkerror.js";
import { SDKValidationError } from "./models/errors/sdkvalidationerror.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";
import { unwrap as unwrap$ } from "./types/fp.js";

export class DocumentSigningAndEligibility extends ClientSDK {
    /**
     * Add a New Payment Eligibility Requirement
     *
     * @remarks
     * Define a new payment eligibility requirement for collaborators in the system.
     */
    async create(
        request?: shared.PaymentEligibility | undefined,
        options?: RequestOptions
    ): Promise<operations.CreatePaymentEligibilityRequirementResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.PaymentEligibility$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/collaborator-settings/payment-eligibility")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "createPaymentEligibilityRequirement",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.CreatePaymentEligibilityRequirementResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CreatePaymentEligibilityRequirementResponse$inboundSchema, {
                key: "PaymentEligibility",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Remove a Specific Eligibility Requirement
     *
     * @remarks
     * Delete an eligibility requirement from the system based on its unique identifier.
     */
    async delete(
        request: operations.DeleteEligibilityRequirementRequest,
        options?: RequestOptions
    ): Promise<operations.DeleteEligibilityRequirementResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.DeleteEligibilityRequirementRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/collaborator-settings/eligibility-requirement/{id}")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "deleteEligibilityRequirement",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.DeleteEligibilityRequirementResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DeleteEligibilityRequirementResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Remove Eligibility Requirement from Collaborator Group
     *
     * @remarks
     * Delete a specific eligibility requirement from the designated collaborator group.
     */
    async deleteCollaboratorGroup(
        request: operations.DeleteEligibilityRequirementCollaboratorGroupRequest,
        options?: RequestOptions
    ): Promise<operations.DeleteEligibilityRequirementCollaboratorGroupResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.DeleteEligibilityRequirementCollaboratorGroupRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            eligibilityRequirementId: encodeSimple$(
                "eligibilityRequirementId",
                payload$.eligibilityRequirementId,
                { explode: false, charEncoding: "percent" }
            ),
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc(
            "/payments/collaborator-group/{id}/eligibility-requirement/{eligibilityRequirementId}"
        )(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "deleteEligibilityRequirementCollaboratorGroup",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.DeleteEligibilityRequirementCollaboratorGroupResponse,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.DeleteEligibilityRequirementCollaboratorGroupResponse$inboundSchema,
                { key: "CollaboratorGroupResponse" }
            )
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Remove a specific Payment Eligibility Requirement
     *
     * @remarks
     * Delete an existing payment eligibility requirement based on its unique identifier, removing associated criteria for a member's payment eligibility.
     */
    async deletePayment(
        request: operations.DeletePaymentEligibilityRequirementRequest,
        options?: RequestOptions
    ): Promise<operations.DeletePaymentEligibilityRequirementResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.DeletePaymentEligibilityRequirementRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/collaborator-settings/payment-eligibility/{id}")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "deletePaymentEligibilityRequirement",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.DeletePaymentEligibilityRequirementResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DeletePaymentEligibilityRequirementResponse$inboundSchema, {
                key: "PaymentEligibility",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Establish a new Eligibility Requirement
     *
     * @remarks
     * Define and create a new eligibility requirement for collaborators.
     */
    async establish(
        request?: shared.EligibilityRequirementCreateRequest | undefined,
        options?: RequestOptions
    ): Promise<operations.EstablishEligibilityRequirementResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                shared.EligibilityRequirementCreateRequest$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/payments/collaborator-settings/eligibility-requirement")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "establishEligibilityRequirement",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.EstablishEligibilityRequirementResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.EstablishEligibilityRequirementResponse$inboundSchema, {
                key: "EligibilityRequirement",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve a Specific Eligibility Requirement
     *
     * @remarks
     * Fetch details for a given eligibility requirement based on its unique identifier.
     */
    async get(
        request: operations.GetEligibilityRequirementRequest,
        options?: RequestOptions
    ): Promise<operations.GetEligibilityRequirementResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.GetEligibilityRequirementRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/collaborator-settings/eligibility-requirement/{id}")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getEligibilityRequirement",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetEligibilityRequirementResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetEligibilityRequirementResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve Specific Collaborator Group Configuration
     *
     * @remarks
     * Fetch detailed configuration and attributes associated with a specific collaborator group.
     */
    async getGroupConfiguration(
        request: operations.GetCollaboratorGroupConfigurationRequest,
        options?: RequestOptions
    ): Promise<operations.GetCollaboratorGroupConfigurationResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.GetCollaboratorGroupConfigurationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/collaborator-group/{id}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getCollaboratorGroupConfiguration",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetCollaboratorGroupConfigurationResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetCollaboratorGroupConfigurationResponse$inboundSchema, {
                key: "CollaboratorGroupResponse",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve details of a specific Payment Eligibility Requirement
     *
     * @remarks
     * Fetch detailed information about a particular payment eligibility requirement using its unique identifier.
     */
    async getPayment(
        request: operations.GetPaymentEligibilityRequirementRequest,
        options?: RequestOptions
    ): Promise<operations.GetPaymentEligibilityRequirementResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.GetPaymentEligibilityRequirementRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/collaborator-settings/payment-eligibility/{id}")(
            pathParams$
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "getPaymentEligibilityRequirement",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.GetPaymentEligibilityRequirementResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.GetPaymentEligibilityRequirementResponse$inboundSchema, {
                key: "PaymentEligibility",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve all Eligibility Requirements
     *
     * @remarks
     * List and display all the set eligibility requirements for collaborators.
     */
    async list(options?: RequestOptions): Promise<operations.ListEligibilityRequirementsResponse> {
        const path$ = pathToFunc("/payments/collaborator-settings/eligibility-requirement")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listEligibilityRequirements",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListEligibilityRequirementsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ListEligibilityRequirementsResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Retrieve All Payment Eligibility Requirements
     *
     * @remarks
     * Obtain a list of all payment eligibility requirements configured for collaborators.
     */
    async listPayment(
        options?: RequestOptions
    ): Promise<operations.ListPaymentEligibilityRequirementsResponse> {
        const path$ = pathToFunc("/payments/collaborator-settings/payment-eligibility")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "listPaymentEligibilityRequirements",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.ListPaymentEligibilityRequirementsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ListPaymentEligibilityRequirementsResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify a Specific Eligibility Requirement
     *
     * @remarks
     * Update specific details or attributes of an existing eligibility requirement.
     */
    async update(
        request: operations.UpdateEligibilityRequirementRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateEligibilityRequirementResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UpdateEligibilityRequirementRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.EligibilityRequirementUpdateRequest, {
            explode: true,
        });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/collaborator-settings/eligibility-requirement/{id}")(
            pathParams$
        );

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateEligibilityRequirement",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateEligibilityRequirementResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateEligibilityRequirementResponse$inboundSchema, {
                key: "classes",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify Eligibility Requirement for Collaborator Group
     *
     * @remarks
     * Update details or attributes of a specific eligibility requirement linked to a collaborator group.
     */
    async updateCollaboratorGroup(
        request: operations.UpdateEligibilityRequirementCollaboratorGroupRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateEligibilityRequirementCollaboratorGroupResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.UpdateEligibilityRequirementCollaboratorGroupRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.CollaboratorGroupRequirementUpdate, {
            explode: true,
        });

        const pathParams$ = {
            eligibilityRequirementId: encodeSimple$(
                "eligibilityRequirementId",
                payload$.eligibilityRequirementId,
                { explode: false, charEncoding: "percent" }
            ),
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc(
            "/payments/collaborator-group/{id}/eligibility-requirement/{eligibilityRequirementId}"
        )(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateEligibilityRequirementCollaboratorGroup",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateEligibilityRequirementCollaboratorGroupResponse,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.UpdateEligibilityRequirementCollaboratorGroupResponse$inboundSchema,
                { key: "CollaboratorGroupResponse" }
            )
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify Collaborator Group Configuration
     *
     * @remarks
     * Update specific attributes or configuration details of an existing collaborator group.
     */
    async updateGroupConfiguration(
        request: operations.UpdateCollaboratorGroupConfigurationRequest,
        options?: RequestOptions
    ): Promise<operations.UpdateCollaboratorGroupConfigurationResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.UpdateCollaboratorGroupConfigurationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.CollaboratorGroupUpdateRequest, {
            explode: true,
        });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/collaborator-group/{id}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updateCollaboratorGroupConfiguration",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdateCollaboratorGroupConfigurationResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdateCollaboratorGroupConfigurationResponse$inboundSchema, {
                key: "CollaboratorGroupResponse",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Modify a specific Payment Eligibility Requirement
     *
     * @remarks
     * Update attributes or criteria of an existing payment eligibility requirement using its unique identifier.
     */
    async updatePayment(
        request: operations.UpdatePaymentEligibilityRequirementRequest,
        options?: RequestOptions
    ): Promise<operations.UpdatePaymentEligibilityRequirementResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.UpdatePaymentEligibilityRequirementRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.PaymentEligibilityUpdateRequest, {
            explode: true,
        });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/payments/collaborator-settings/payment-eligibility/{id}")(
            pathParams$
        );

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const bearerAuth$ = await extractSecurity(this.options$.bearerAuth);
        const security$ = bearerAuth$ == null ? {} : { bearerAuth: bearerAuth$ };
        const context = {
            operationID: "updatePaymentEligibilityRequirement",
            oAuth2Scopes: [],
            securitySource: this.options$.bearerAuth,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: [],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.UpdatePaymentEligibilityRequirementResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UpdatePaymentEligibilityRequirementResponse$inboundSchema, {
                key: "PaymentEligibility",
            })
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }
}
